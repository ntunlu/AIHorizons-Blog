<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Naim Teoman Ünlü">
<meta name="description" content="Yapay zekâ alanında devrim niteliğinde gelişmeler yaşanıyor. Son yıllarda özellikle büyük dil modelleri (LLM’ler), hem teknoloji dünyasında hem de kamuoyunda büyük bir heyecan yarattı. ChatGPT, Copilot, Claude, Llama, Grok gibi modeller artık günlük hayatın bir parçası. Ancak bu modellerin gerçekten “yapay genel zekâya - Artificial General Intelligence (AGI)” sahip olup olamayacağı hâlâ büyük bir soru işareti.">

<title>JEPA: Geleneksel LLM’lerin Ötesinde Yeni Nesil Yapay Zekâ Mimarisi – AIHorizons- by NTU</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-df479d6c4d77d0e0dfbcb5361179d7fd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sonuç yok",
    "search-matching-documents-text": "eşleşen belgeler",
    "search-copy-link-title": "Aramak için bağlantıyı kopyalayın",
    "search-hide-matches-text": "Ek eşleşmeleri gizle",
    "search-more-match-text": "bu belgede daha fazla eşleşme",
    "search-more-matches-text": "bu belgede daha fazla eşleşmeler",
    "search-clear-button-title": "Temizle",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "İptal et",
    "search-submit-button-title": "Göndermek",
    "search-label": "Aramak"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">AIHorizons- by NTU</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Aramak"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Gezinmeyi değiştir" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Ana Sayfa</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Hakkında</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title"><strong>JEPA: Geleneksel LLM’lerin Ötesinde Yeni Nesil Yapay Zekâ Mimarisi</strong></h1>
                  <div>
        <div class="description">
          Yapay zekâ alanında devrim niteliğinde gelişmeler yaşanıyor. Son yıllarda özellikle büyük dil modelleri (LLM’ler), hem teknoloji dünyasında hem de kamuoyunda büyük bir heyecan yarattı. ChatGPT, Copilot, Claude, Llama, Grok gibi modeller artık günlük hayatın bir parçası. Ancak bu modellerin gerçekten <strong>“yapay genel zekâya - Artificial General Intelligence (AGI)”</strong> sahip olup olamayacağı hâlâ büyük bir soru işareti.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">AGI</div>
                <div class="quarto-category">Expert Opinion</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Yazar</div>
      <div class="quarto-title-meta-contents">
               <p>Naim Teoman Ünlü </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Yayınlanma Tarihi</div>
      <div class="quarto-title-meta-contents">
        <p class="date">23 Nisan 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<blockquote class="blockquote">
<p><strong>Sesli Dinle</strong></p>
<audio controls="">
<source src="JEPA.mp3" type="audio/mpeg">
<p>Your browser does not support the audio element. </p>
</audio></blockquote>
<p>İşte bu noktada sahneye çıkan önemli bir isim var: <strong>Yann LeCun</strong>. Yapay zekânın öncülerinden biri olan LeCun, NVIDIA GTC 2025 etkinliğinde yaptığı açıklamada çarpıcı bir görüş dile getirdi: <strong>“Artık LLM’lerle ilgilenmiyorum.”</strong> Bu iddialı ifade, aslında çok daha derin bir yaklaşımın habercisiydi. LeCun, yapay zekânın geleceğinin farklı bir yönde ilerlemesi gerektiğini savunuyor ve bu yolculukta LLM’lerin sınırlı bir rolü olduğunu belirtiyor.</p>
<p>YouTube Video Link: <a href="https://www.youtube.com/watch?v=p1QXZHV4jkM">Buradan izleyebilirsiniz.</a></p>
<section id="llmler-neden-yetersiz" class="level2">
<h2 class="anchored" data-anchor-id="llmler-neden-yetersiz">LLM’ler Neden Yetersiz?</h2>
<p>LeCun’a göre LLM’ler, <strong>çoğunlukla metin tabanlı veriyle eğitilen, bir sonraki kelimeyi tahmin eden</strong> sistemlerdir. Bu sistemler, ürünlerde küçük iyileştirmeler yapmaya elverişli olabilir ancak <strong>gerçek dünya bilgisiyle derinlemesine etkileşim kuramazlar</strong>. Çünkü kelimelerle sınırlı bir temsil biçimi, fiziksel dünya gibi karmaşık ve sürekli değişen bir ortamı anlamak için yeterli değildir.</p>
<p>Dahası, LLM’ler <strong>dört temel alanda yetersiz kalıyor</strong>:</p>
<p><img src="llmeksikler.png" class="img-fluid" width="372"></p>
<p>LeCun, bu alanların yapay zekânın geleceği için kritik olduğunu ve LLM mimarilerinin bu ihtiyaçlara cevap veremediğini vurguluyor.</p>
</section>
<section id="dünya-modelleri-ve-yeni-yönelimler" class="level2">
<h2 class="anchored" data-anchor-id="dünya-modelleri-ve-yeni-yönelimler">Dünya Modelleri ve Yeni Yönelimler</h2>
<p>LeCun’un önerdiği yaklaşımın temelinde <strong>“dünya modeli”</strong> fikri yatıyor. Bu kavram, yapay zekânın çevresini tıpkı bir insan gibi “içsel bir modelle” anlayabilmesini ifade ediyor. Örneğin, bir nesneyi yukarıdan ittirdiğinizde devrileceğini ya da aşağı kısmından ittiğinizde kayacağını bilmek, insanların doğrudan gözlemle kazandığı bir yetidir. LeCun, yapay zekânın da benzer şekilde çevresini anlaması gerektiğini söylüyor.</p>
<p>Bunu başarmak için önerdiği çözüm ise: <strong>JEPA (Joint Embedding Predictive Architecture) (Ortak Gömülü Öngörüsel Mimari)</strong>.</p>
</section>
<section id="jepa-mimarisi-yeni-nesil-zeka" class="level2">
<h2 class="anchored" data-anchor-id="jepa-mimarisi-yeni-nesil-zeka">JEPA Mimarisi: Yeni Nesil Zeka</h2>
<p>JEPA, klasik LLM’lerin aksine, <strong>üretici olmayan (non-generative)</strong> ve <strong>soyut temsil tahmini yapan</strong> bir mimaridir. LeCun’un açıklamalarına göre, JEPA modeli doğrudan piksel tahmini yapmaz. Onun yerine, videolarda ya da verilerde gizlenmiş bölümleri <strong>soyut bir temsil uzayında</strong> tahmin eder. Bu da modeli daha verimli, daha anlamlı ve gerçek dünya bağlamıyla daha uyumlu hale getirir.</p>
<section id="soyut-temsil-öğrenimi" class="level3">
<h3 class="anchored" data-anchor-id="soyut-temsil-öğrenimi">Soyut Temsil Öğrenimi</h3>
<p>JEPA, geleneksel modellerin yaptığı gibi g<strong>irdiyi olduğu gibi yeniden üretmeye çalışmak yerine; girdinin soyut özelliklerini temsili bir uzayda öğrenmeye ve bu uzayda anlamlı ilişkiler kurarak çıkarımlar yapmaya odaklanır.</strong> Bu da, sistemi daha verimli, daha esnek ve insan kavrayışıyla daha uyumlu hâle getirir; çünkü insanlar da çevrelerini piksel düzeyinde değil, kavramsal düzeyde algılar ve yorumlar.</p>
</section>
<section id="maskeleme-ile-öngörüsel-öğrenme" class="level3">
<h3 class="anchored" data-anchor-id="maskeleme-ile-öngörüsel-öğrenme">Maskeleme ile Öngörüsel Öğrenme</h3>
<p>Modelin eğitimi sırasında, video veya veri akışının belirli bölümleri kasıtlı olarak maskelenir; ardından JEPA, eksik kalan parçaları, ham görsellerle değil, temsil uzayındaki soyut özelliklerle tamamlamaya çalışır. Bu strateji sayesinde, <strong>model yalnızca verinin “görünüşünü” değil, altında yatan “anlamını” da kavrayabilir;</strong> örneğin, bir videonun belirli bir karesi eksildiğinde, JEPA bu karede ne olabileceğini görsel sadakatle değil, bağlamsal bütünlükle tahmin eder.</p>
</section>
<section id="dünya-modeli-yeteneği" class="level3">
<h3 class="anchored" data-anchor-id="dünya-modeli-yeteneği">Dünya Modeli Yeteneği</h3>
<p>JEPA, doğadan alınmış video verileri üzerinde eğitilerek, tıpkı insanlarda olduğu gibi bir dünya modeli geliştirir; bu model, nesnelerin hareketlerine ilişkin sezgisel fizik kurallarını içselleştirir. Örneğin; bir nesnenin havada süzülüp süzülemeyeceği, kaybolup kaybolmaması gerektiği veya şeklinin doğal olmayan biçimde değişip değişmediği gibi olayların fiziki doğruluğunu analiz edebilir; bu da, <strong>yapay zekânın yalnızca görsel değil, mantıksal tutarlılıkla da olayları değerlendirebilmesini sağlar.</strong></p>
</section>
<section id="az-veriyle-verimli-öğrenme" class="level3">
<h3 class="anchored" data-anchor-id="az-veriyle-verimli-öğrenme">Az Veriyle Verimli Öğrenme</h3>
<p>JEPA, LLM’lerin ihtiyaç duyduğu devasa miktarda veriyle değil;<strong>tıpkı çocukların birkaç örnekle kavram öğrenmesi gibi, az sayıda örnekle etkili öğrenme gerçekleştirebilir.</strong> Bu özellik, hem veri kaynaklarının sınırlı olduğu durumlar için avantaj sağlar hem de eğitimi daha verimli ve sürdürülebilir hâle getirir.Meta’nın geliştirdiği bu mimari, insan öğrenmesine oldukça benzer şekilde çalışır.</p>
</section>
</section>
<section id="transformer-yerine-neden-jepa" class="level2">
<h2 class="anchored" data-anchor-id="transformer-yerine-neden-jepa">Transformer Yerine Neden JEPA?</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Özellik</th>
<th>Transformer (LLM, VideoGen)</th>
<th>JEPA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Öğrenme Türü</td>
<td>Token/Piksel Tahmini</td>
<td>Temsil Üzerinden Tahmin</td>
</tr>
<tr class="even">
<td>Verimlilik</td>
<td>Yüksek işlem gücü, çok veri</td>
<td>Daha az veri ile etkili</td>
</tr>
<tr class="odd">
<td>Gerçeklik Bağlantısı</td>
<td>Zayıf, metin tabanlı</td>
<td>Güçlü, video ve fiziksel bağlam</td>
</tr>
<tr class="even">
<td>Akıl Yürütme</td>
<td>Söz dizimi temelli</td>
<td>Kavramsal ve açık</td>
</tr>
</tbody>
</table>
</section>
<section id="sistem-1-ve-sistem-2-düşünme-modelleri" class="level2">
<h2 class="anchored" data-anchor-id="sistem-1-ve-sistem-2-düşünme-modelleri">Sistem 1 ve Sistem 2 Düşünme Modelleri</h2>
<p>LeCun, yapay zekâda “düşünme” kavramına da önemli bir boyut ekliyor: <strong>Sistem 1 ve Sistem 2 düşünme modelleri</strong>. Psikolojide yer alan bu yaklaşım, insanların iki tür düşünme biçimi olduğunu söyler:</p>
<ul>
<li><p><strong>Sistem 1</strong>: Hızlı, sezgisel ve otomatik düşünmedir. (Örnek: Deneyimli bir sürücünün araç kullanması)</p></li>
<li><p><strong>Sistem 2</strong>: Yavaş, mantıklı ve planlı düşünmedir. (Örnek: Satrançta strateji kurmak)</p></li>
</ul>
<p>LLM’ler, genellikle Sistem 1 tipi davranışlar sergiler. Ancak LeCun’a göre gerçek AGI’ye ulaşmak için <strong>Sistem 2 düşünce biçimini taklit eden mimarilere ihtiyaç vardır</strong>. JEPA mimarisi, bu tür “akıl yürütme” süreçlerine daha uygun bir zemin sunar.</p>
</section>
<section id="sadece-metinle-agi-mümkün-mü" class="level2">
<h2 class="anchored" data-anchor-id="sadece-metinle-agi-mümkün-mü">Sadece Metinle AGI Mümkün mü?</h2>
<p>LeCun, metinle eğitilen sistemlerin veri sınırlarını da gündeme getiriyor. Şu anda LLM’ler yaklaşık <strong>30 trilyon token</strong> ile eğitiliyor. Bu miktarda metni okumak bir insan için <strong>400 bin yıl</strong> sürerdi. Ancak <strong>bir çocuk, sadece 4 yaşına kadar olan süreçte, görsel yollarla benzer büyüklükte bir veri alıyor.</strong> Bu, <strong>görsel ve deneyimsel öğrenmenin</strong> ne kadar önemli olduğunu gösteriyor.</p>
</section>
<section id="sonuç-agiye-giden-yol-farklı" class="level2">
<h2 class="anchored" data-anchor-id="sonuç-agiye-giden-yol-farklı">Sonuç: AGI’ye Giden Yol Farklı</h2>
<p>Yann LeCun’un bu açıklamaları, yapay zekâda yeni bir çağın başlangıcına işaret ediyor olabilir. Büyük dil modelleri her ne kadar şu an için etkileyici uygulamalar sunsa da, <strong>gerçek anlamda genel yapay zekâya sahip sistemler;</strong>, <strong>fiziksel dünyayı anlayan</strong>, <strong>plan yapabilen</strong> ve <strong>soyut düşünebilen</strong> mimarilerle mümkün olacak.</p>
<p>JEPA gibi yaklaşımlar, <strong>yapay zekânın sadece veriyi işleyen değil, dünyayı anlayan bir varlığa dönüşmesini</strong> sağlayabilir. Belki de gelecekteki AGI sistemleri, LLM’lerin bir uzantısı değil; onlardan tamamen farklı, <strong>çok daha derin ve esnek</strong> yapılar olacak.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopyalandı");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopyalandı");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>